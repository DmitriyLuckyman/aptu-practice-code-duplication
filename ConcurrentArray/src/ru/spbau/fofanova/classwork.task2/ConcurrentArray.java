package ru.spbau.fofanova.classwork.task2;

import java.util.ArrayList;
import java.util.Random;

/**
 * Class of main.
 *
 * @author: Maria Fofanova
 */
public class ConcurrentArray {
    final static ArrayList<Thread> threads = new ArrayList<Thread>();
    static ArrayList<Integer> array = new ArrayList<Integer>();
    static final Object bigResultmonitor = new Object();
    static int bigResult = 0;
    static final Object numberOfFinishedMonitor = new Object();
    static int numberOfFinished = 0;

    /**
     * Creates certain number of threads that create certain number of small threads. Each small thread counts a sum of
     * the certain part of the array. The array of certain size is generated by random.
     * @param args Number of big threads, number of small threads in each big thread, size of the array.
     */
    public static void main(String args[]) {
        int threadsNumber = Integer.parseInt(args[0]);
        int smallThreadsNumber = Integer.parseInt(args[1]);
        array = generateArray(Integer.parseInt(args[2]));
        System.out.println(array);
        for (int i = 0; i < threadsNumber; ++i) {
            if (i < threadsNumber - 1) {
                threads.add(new Thread(new SumCountProcessor(i * array.size() / threadsNumber,
                        (i + 1) * array.size() / threadsNumber, smallThreadsNumber)));
            } else {
                threads.add(new Thread(new SumCountProcessor((threadsNumber - 1) * array.size() / threadsNumber,
                        array.size(), smallThreadsNumber)));
            }
        }
        for (int i = 0; i < threadsNumber; ++i) {
            threads.get(i).start();
        }
        synchronized (numberOfFinishedMonitor) {
            while (numberOfFinished != threadsNumber) {
                try {
                    numberOfFinishedMonitor.wait();
                } catch (InterruptedException e) {
                    System.err.println("Error during counting!");
                    e.printStackTrace();
                    System.exit(1);
                }
            }
        }
        System.out.print("Last result ");
        System.out.println(bigResult);
        int sum = 0;
        for (Integer i : array){
            sum += i;
        }
        System.out.println(sum);
    }

    private static ArrayList<Integer> generateArray(int size) {
        final ArrayList<Integer> result = new ArrayList<Integer>();
        final Random random = new Random(System.currentTimeMillis());
        for (int i = 0; i < size; ++i) {
            result.add(random.nextInt(1000));
        }
        return result;
    }

    private static class SumCountProcessor implements Runnable {
        private final int begin;
        private final int end;
        private final int numberOfThreads;
        private final Object resultMonitor = new Object();
        private int result = 0;
        private final Object doneCountMonitor = new Object();
        private int doneCount = 0;

        @Override
        public void run() {
            final ArrayList<Thread> threads = new ArrayList<Thread>();
            for (int i = 0; i < numberOfThreads; ++i) {
                if (i < numberOfThreads - 1) {
                    threads.add(new Thread(new SumCountPreProcessor(begin + i * (end - begin) / numberOfThreads,
                            begin + (i + 1) * (end - begin) / numberOfThreads)));
                } else {
                    threads.add(new Thread(new SumCountPreProcessor(
                            begin + (numberOfThreads - 1) * (end - begin) / numberOfThreads,
                            end)));
                }
            }

            for (int i = 0; i < numberOfThreads; ++i) {
                threads.get(i).start();
            }
            synchronized (doneCountMonitor){
                while (doneCount < numberOfThreads){
                    try {
                        doneCountMonitor.wait();
                    } catch (InterruptedException e) {
                        break;
                    }
                }
            }
            synchronized (bigResultmonitor) {
                bigResult += result;
            }
            synchronized (numberOfFinishedMonitor) {
                ++numberOfFinished;
                numberOfFinishedMonitor.notify();
            }
        }

        private class SumCountPreProcessor implements Runnable {
            private final int begin;
            private final int end;

            public SumCountPreProcessor(int begin, int end) {
                this.begin = begin;
                this.end = end;
            }

            @Override
            public void run() {
                int subRes = 0;
                for (int i = begin; i < end; ++i) {
                    subRes += array.get(i);
                }
                synchronized (resultMonitor){
                    result += subRes;
                }
                synchronized (doneCountMonitor){
                    ++doneCount;
                    doneCountMonitor.notify();
                }
            }
        }

        public SumCountProcessor(int begin, int end, int numberOfThreads) {
            this.begin = begin;
            this.end = end;
            this.numberOfThreads = numberOfThreads;
        }
    }
}
